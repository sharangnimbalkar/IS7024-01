// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Welcome
    {
        [JsonProperty("meta")]
        public Meta Meta { get; set; }

        [JsonProperty("data")]
        public Datum[][] Data { get; set; }
    }

    public partial class Meta
    {
        [JsonProperty("view")]
        public View View { get; set; }
    }

    public partial class View
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("attribution")]
        public string Attribution { get; set; }

        [JsonProperty("averageRating")]
        public long AverageRating { get; set; }

        [JsonProperty("category")]
        public string Category { get; set; }

        [JsonProperty("createdAt")]
        public long CreatedAt { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("displayType")]
        public string DisplayType { get; set; }

        [JsonProperty("downloadCount")]
        public long DownloadCount { get; set; }

        [JsonProperty("hideFromCatalog")]
        public bool HideFromCatalog { get; set; }

        [JsonProperty("hideFromDataJson")]
        public bool HideFromDataJson { get; set; }

        [JsonProperty("indexUpdatedAt")]
        public long IndexUpdatedAt { get; set; }

        [JsonProperty("licenseId")]
        public string LicenseId { get; set; }

        [JsonProperty("newBackend")]
        public bool NewBackend { get; set; }

        [JsonProperty("numberOfComments")]
        public long NumberOfComments { get; set; }

        [JsonProperty("oid")]
        public long Oid { get; set; }

        [JsonProperty("provenance")]
        public string Provenance { get; set; }

        [JsonProperty("publicationAppendEnabled")]
        public bool PublicationAppendEnabled { get; set; }

        [JsonProperty("publicationDate")]
        public long PublicationDate { get; set; }

        [JsonProperty("publicationGroup")]
        public long PublicationGroup { get; set; }

        [JsonProperty("publicationStage")]
        public string PublicationStage { get; set; }

        [JsonProperty("rowsUpdatedAt")]
        public long RowsUpdatedAt { get; set; }

        [JsonProperty("rowsUpdatedBy")]
        public string RowsUpdatedBy { get; set; }

        [JsonProperty("tableId")]
        public long TableId { get; set; }

        [JsonProperty("totalTimesRated")]
        public long TotalTimesRated { get; set; }

        [JsonProperty("viewCount")]
        public long ViewCount { get; set; }

        [JsonProperty("viewLastModified")]
        public long ViewLastModified { get; set; }

        [JsonProperty("viewType")]
        public string ViewType { get; set; }

        [JsonProperty("approvals")]
        public Approval[] Approvals { get; set; }

        [JsonProperty("columns")]
        public Column[] Columns { get; set; }

        [JsonProperty("grants")]
        public Grant[] Grants { get; set; }

        [JsonProperty("license")]
        public License License { get; set; }

        [JsonProperty("metadata")]
        public Metadata Metadata { get; set; }

        [JsonProperty("owner")]
        public Owner Owner { get; set; }

        [JsonProperty("query")]
        public Query Query { get; set; }

        [JsonProperty("rights")]
        public string[] Rights { get; set; }

        [JsonProperty("tableAuthor")]
        public Owner TableAuthor { get; set; }

        [JsonProperty("tags")]
        public string[] Tags { get; set; }

        [JsonProperty("flags")]
        public string[] Flags { get; set; }
    }

    public partial class Approval
    {
        [JsonProperty("reviewedAt")]
        public long ReviewedAt { get; set; }

        [JsonProperty("reviewedAutomatically")]
        public bool ReviewedAutomatically { get; set; }

        [JsonProperty("state")]
        public string State { get; set; }

        [JsonProperty("submissionId")]
        public long SubmissionId { get; set; }

        [JsonProperty("submissionObject")]
        public string SubmissionObject { get; set; }

        [JsonProperty("submissionOutcome")]
        public string SubmissionOutcome { get; set; }

        [JsonProperty("submittedAt")]
        public long SubmittedAt { get; set; }

        [JsonProperty("workflowId")]
        public long WorkflowId { get; set; }

        [JsonProperty("submissionDetails")]
        public SubmissionDetails SubmissionDetails { get; set; }

        [JsonProperty("submissionOutcomeApplication")]
        public SubmissionOutcomeApplication SubmissionOutcomeApplication { get; set; }

        [JsonProperty("submitter")]
        public Submitter Submitter { get; set; }
    }

    public partial class SubmissionDetails
    {
        [JsonProperty("permissionType")]
        public string PermissionType { get; set; }
    }

    public partial class SubmissionOutcomeApplication
    {
        [JsonProperty("failureCount")]
        public long FailureCount { get; set; }

        [JsonProperty("status")]
        public string Status { get; set; }
    }

    public partial class Submitter
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("displayName")]
        public string DisplayName { get; set; }
    }

    public partial class Column
    {
        [JsonProperty("id")]
        public long Id { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("dataTypeName")]
        public TypeName DataTypeName { get; set; }

        [JsonProperty("fieldName")]
        public string FieldName { get; set; }

        [JsonProperty("position")]
        public long Position { get; set; }

        [JsonProperty("renderTypeName")]
        public TypeName RenderTypeName { get; set; }

        [JsonProperty("format")]
        public Format Format { get; set; }

        [JsonProperty("flags", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Flags { get; set; }

        [JsonProperty("tableColumnId", NullValueHandling = NullValueHandling.Ignore)]
        public long? TableColumnId { get; set; }

        [JsonProperty("width", NullValueHandling = NullValueHandling.Ignore)]
        public long? Width { get; set; }

        [JsonProperty("cachedContents", NullValueHandling = NullValueHandling.Ignore)]
        public CachedContents CachedContents { get; set; }
    }

    public partial class CachedContents
    {
        [JsonProperty("largest")]
        public string Largest { get; set; }

        [JsonProperty("null")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Null { get; set; }

        [JsonProperty("top")]
        public Top[] Top { get; set; }

        [JsonProperty("not_null")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long NotNull { get; set; }

        [JsonProperty("smallest")]
        public string Smallest { get; set; }

        [JsonProperty("cardinality")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Cardinality { get; set; }
    }

    public partial class Top
    {
        [JsonProperty("item")]
        public string Item { get; set; }

        [JsonProperty("count")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long Count { get; set; }
    }

    public partial class Format
    {
        [JsonProperty("precisionStyle", NullValueHandling = NullValueHandling.Ignore)]
        public string PrecisionStyle { get; set; }

        [JsonProperty("noCommas", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyParseStringConverter))]
        public bool? NoCommas { get; set; }

        [JsonProperty("align", NullValueHandling = NullValueHandling.Ignore)]
        public string Align { get; set; }
    }

    public partial class Grant
    {
        [JsonProperty("inherited")]
        public bool Inherited { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("flags")]
        public string[] Flags { get; set; }
    }

    public partial class License
    {
        [JsonProperty("name")]
        public string Name { get; set; }
    }

    public partial class Metadata
    {
        [JsonProperty("rdfSubject")]
        [JsonConverter(typeof(PurpleParseStringConverter))]
        public long RdfSubject { get; set; }

        [JsonProperty("rowLabel")]
        public string RowLabel { get; set; }
    }

    public partial class Owner
    {
        [JsonProperty("id")]
        public string Id { get; set; }

        [JsonProperty("displayName")]
        public string DisplayName { get; set; }

        [JsonProperty("screenName")]
        public string ScreenName { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("flags")]
        public string[] Flags { get; set; }
    }

    public partial class Query
    {
    }

    public enum TypeName { CalendarDate, MetaData, Number, Text };

    public partial struct Datum
    {
        public long? Integer;
        public string String;

        public static implicit operator Datum(long Integer) => new Datum { Integer = Integer };
        public static implicit operator Datum(string String) => new Datum { String = String };
        public bool IsNull => Integer == null && String == null;
    }

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DatumConverter.Singleton,
                TypeNameConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DatumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Datum) || t == typeof(Datum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new Datum { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Datum { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Datum { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type Datum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Datum)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type Datum");
        }

        public static readonly DatumConverter Singleton = new DatumConverter();
    }

    internal class PurpleParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly PurpleParseStringConverter Singleton = new PurpleParseStringConverter();
    }

    internal class TypeNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeName) || t == typeof(TypeName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "calendar_date":
                    return TypeName.CalendarDate;
                case "meta_data":
                    return TypeName.MetaData;
                case "number":
                    return TypeName.Number;
                case "text":
                    return TypeName.Text;
            }
            throw new Exception("Cannot unmarshal type TypeName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeName)untypedValue;
            switch (value)
            {
                case TypeName.CalendarDate:
                    serializer.Serialize(writer, "calendar_date");
                    return;
                case TypeName.MetaData:
                    serializer.Serialize(writer, "meta_data");
                    return;
                case TypeName.Number:
                    serializer.Serialize(writer, "number");
                    return;
                case TypeName.Text:
                    serializer.Serialize(writer, "text");
                    return;
            }
            throw new Exception("Cannot marshal type TypeName");
        }

        public static readonly TypeNameConverter Singleton = new TypeNameConverter();
    }

    internal class FluffyParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(bool) || t == typeof(bool?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            bool b;
            if (Boolean.TryParse(value, out b))
            {
                return b;
            }
            throw new Exception("Cannot unmarshal type bool");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (bool)untypedValue;
            var boolString = value ? "true" : "false";
            serializer.Serialize(writer, boolString);
            return;
        }

        public static readonly FluffyParseStringConverter Singleton = new FluffyParseStringConverter();
    }
}
